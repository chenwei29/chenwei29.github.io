<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/touxiang.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/touxiang.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/touxiang.jpg">
  <link rel="mask-icon" href="/images/touxiang.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="springboot简介 约定大于配置 : 按约定编程,是一种软件设计范式,目的是减少开发人员减少做决定的数量(就是规定制定文件放在什么位置).  springboot中的约定有 : Maven的目录结构.默认resource文件夹存放配置文件.默认生成的编译后的代码都在target文件夹下.springboot默认的配置文件为:application开头等等一些.  含有丰富的start,拿来即">
<meta property="og:type" content="article">
<meta property="og:title" content="springboot">
<meta property="og:url" content="http://example.com/2021/05/15/springboot/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="springboot简介 约定大于配置 : 按约定编程,是一种软件设计范式,目的是减少开发人员减少做决定的数量(就是规定制定文件放在什么位置).  springboot中的约定有 : Maven的目录结构.默认resource文件夹存放配置文件.默认生成的编译后的代码都在target文件夹下.springboot默认的配置文件为:application开头等等一些.  含有丰富的start,拿来即">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/05/15/springboot/OH@P%5DI3%25KDUXH%7DH54%25%7BHUUN.png">
<meta property="og:image" content="http://example.com/2021/05/15/springboot/image-20210529222903580.png">
<meta property="og:image" content="http://example.com/2021/05/15/springboot/image-20210530223007086.png">
<meta property="og:image" content="http://example.com/2021/05/15/springboot/image-20210530223739907.png">
<meta property="article:published_time" content="2021-05-15T07:25:30.000Z">
<meta property="article:modified_time" content="2021-07-14T01:12:42.238Z">
<meta property="article:author" content="cw">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/05/15/springboot/OH@P%5DI3%25KDUXH%7DH54%25%7BHUUN.png">

<link rel="canonical" href="http://example.com/2021/05/15/springboot/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>springboot | 博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">积跬步，至千里</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#springboot%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">springboot简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="nav-number">2.</span> <span class="nav-text">快速上手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">微服务和分布式的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springboot%E6%B3%A8%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">springboot注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">5.</span> <span class="nav-text">springboot自动配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springboot%E7%9A%84web%E5%BC%80%E5%8F%91"><span class="nav-number">6.</span> <span class="nav-text">springboot的web开发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95"><span class="nav-number">6.0.1.</span> <span class="nav-text">静态资源资源目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E7%9A%84%E5%89%8D%E7%BC%80"><span class="nav-number">6.0.2.</span> <span class="nav-text">静态资源访问的前缀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="nav-number">6.0.3.</span> <span class="nav-text">静态资源配置原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">6.0.3.1.</span> <span class="nav-text">配置类只有一个有参构造器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#restful%E9%A3%8E%E6%A0%BC"><span class="nav-number">6.0.4.</span> <span class="nav-text">restful风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86"><span class="nav-number">6.0.5.</span> <span class="nav-text">请求映射原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#cookie%E8%A2%AB%E7%A6%81%E7%94%A8%E4%BA%86-session%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E6%80%8E%E4%B9%88%E8%8E%B7%E5%BE%97"><span class="nav-number">6.0.5.1.</span> <span class="nav-text">cookie被禁用了,session里面的内容怎么获得?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="nav-number">6.0.6.</span> <span class="nav-text">请求流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-number">6.1.</span> <span class="nav-text">拦截器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.1.</span> <span class="nav-text">拦截器原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-number">6.2.</span> <span class="nav-text">文件上传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%B5%8C%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">6.3.</span> <span class="nav-text">内嵌服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">6.3.1.</span> <span class="nav-text">切换服务器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E5%8C%96Web"><span class="nav-number">6.4.</span> <span class="nav-text">定制化Web</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">6.4.1.</span> <span class="nav-text">常用方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E7%9A%84%E6%95%B4%E5%90%88"><span class="nav-number">6.5.</span> <span class="nav-text">redis的整合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Junit%E7%9A%84%E6%95%B4%E5%90%88"><span class="nav-number">6.6.</span> <span class="nav-text">Junit的整合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7"><span class="nav-number">6.7.</span> <span class="nav-text">指标监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#profile%E5%8A%9F%E8%83%BD"><span class="nav-number">6.8.</span> <span class="nav-text">profile功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%96%91%E9%97%AE%E7%82%B9"><span class="nav-number">7.</span> <span class="nav-text">疑问点</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="cw"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">cw</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/15/springboot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="cw">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          springboot
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-15 15:25:30" itemprop="dateCreated datePublished" datetime="2021-05-15T15:25:30+08:00">2021-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-14 09:12:42" itemprop="dateModified" datetime="2021-07-14T09:12:42+08:00">2021-07-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="springboot简介"><a href="#springboot简介" class="headerlink" title="springboot简介"></a>springboot简介</h2><p> 约定大于配置 : 按约定编程,是一种软件设计范式,目的是减少开发人员减少做决定的数量(就是规定制定文件放在什么位置).</p>
<p> springboot中的约定有 : Maven的目录结构.默认resource文件夹存放配置文件.默认生成的编译后的代码都在target文件夹下.springboot默认的配置文件为:application开头等等一些.</p>
<p> 含有丰富的start,拿来即用.</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p> 在springboot项目中,加入打包插件后打成jar包 ,在 cmd界面启动jar包 命令: java -jar [文件名.jar]</p>
<p> 修改配置或者写自己的配置:首先创建一个application.properties或者application.yml文件(约定大于配置),比如修改端口号 server.port=xxxx; 增加虚拟路径: server.servlet.context-path= url</p>
<span id="more"></span>

<h2 id="微服务和分布式的区别"><a href="#微服务和分布式的区别" class="headerlink" title="微服务和分布式的区别"></a>微服务和分布式的区别</h2><p> 微服务: 是一种架构放个,一个应用可以拆分为一组小型服务,每个服务都可以运行在自己的进程内,也就是可独立部署和升级.服务间使用轻量级http(推荐)交互</p>
<p> 分布式: 将一个大的系统分成多个模块,,业务模块部署到不同的机器上,各个业务模块之间通过接口来进行交互,<br>​ 分布式容易出现的问题: 远程调用,服务发现,负载均衡,服务容错, 配置管理,服务监控,链路追踪,日志管理,任务调度,事务管理.</p>
<p> 集群: 就是很多相同的服务,一个或者多台服务器部署相同应用构成一个集群.</p>
<p> 微服务重在解耦合,使得每个模块都独立,分布式重在资源的共享和加快计算机的响应速度.一个是分散能力,一个是分散压力.</p>
<h2 id="springboot注解"><a href="#springboot注解" class="headerlink" title="springboot注解"></a>springboot注解</h2><p> 默认的扫描规则: 在启动类(<code>@SpringbootApplication</code>)所在包及子包是默认扫描的,<br>​ 想要改变扫描路径.可以手动修改,在<code>@SpringbootApplication(scanBasePackages=&quot;xxx&quot;)</code>就行,或者<code>@ComponentScan</code> (包扫描) 指定扫描路径.</p>
<p> <code>@SpringBootApplication</code>等同于<code>@SpringBootConfiguration</code> + <code>@EnableAutoConfiguration</code> + <code>@ComponentScan</code></p>
<p> <code>@Configuration</code> 表示这个一个配置类 ,相当于spring中的配置文件。在springboot中,proxyBeanMethods是默认=true的(proxyBeanMethods: 是不是代理类的方法,如果是true,那么就是代理对象调用方法,去检查容器中,是否有该组件,有就从容器中拿.如果是false,那么就不是代理对象了,就是每次都是新new一个对象)<br>​ spring的配置模式FULL 和 LITE 模式 : proxyBeanMethods=true为FULL 全局配置模式,LITE就是轻量级模式.用来管理组件依赖问题.<br>​ LITE的优点是 在springboot项目启动的时候,不会去检查那些组件在没在容器中,启动更快.使用情况,如果只是在容器中注册组件,而不依赖其他的组件,别的也不依赖这个组件,建议用false</p>
<p> <code>@Bean</code> 在配置类中标注在方法的时候，返回一个name为方法名类型为返回值的组件，默认是单例的。</p>
<p> <code>@Import</code> 位置: 只要在容器中的组件上就行(要能扫描到). 此注解中的参数为一个Class的数组,可以自动的在容器中调用指定的无参构造方法,创建出组件类型的对象.默认组件的名字就是全类名.</p>
<p> <code>@ConditionalOnxxx</code>条件装配: 满足他的条件的时候则进行组件的注入</p>
<p> <code>@ImportResource</code> 导入一个资源文件</p>
<p> <code>@ConfigurationProperties</code> 配置绑定, 位置: 在此类标注<code>@Component</code>或在配置类上<code>@EnableConfigurationProperties</code> 指定该类才能使用此注解,其中属性 prefix,表示与配置文件的哪 个前缀进行绑定</p>
<p> <code>@EnableConfigurationProperties</code> 开启属性配置功能,位置 : 在配置类上. 此注解的属性为Class,指的是开启这个类的配置配置功能,还可以把该类自动注入到容器中.</p>
<p><code>@EnableWebMvc</code> 当使用<code>@EnableWebMvc</code>时，加载的是WebMvcConfigurationSupport中的配置项。也就是springboot中自己自动装配就不发生了.只有WebMvcConfigurationSupport提供的组件和自定义的组件了.<br>    当不使用<code>@EnableWebMvc</code>时，使用的是WebMvcAutoConfiguration引入的配置项。</p>
<h2 id="springboot自动配置"><a href="#springboot自动配置" class="headerlink" title="springboot自动配置"></a>springboot自动配置</h2><p> 每项的配置都有着默认值,配置文件的值最终会绑定在对应的类上,容器启动时,就会把这些配置文件对应的值赋值到对应的类上(一般是 xxxxxproperties)</p>
<p> springboot的自动配置是按需加载所有的自动配置项. 导入对应的starter才会导入对应的配置类.所有的自动配置来自<code>springboot-boot-autoconfigure</code>包中<br><img src="/2021/05/15/springboot/OH@P%5DI3%25KDUXH%7DH54%25%7BHUUN.png" alt="img"></p>
<p> 要先分析springboot,首先要从他的启动类注解<code>@SpringBootApplication</code>开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication&#123;&#125;</span><br></pre></td></tr></table></figure>

<p> 1 <code>@SpringBootConfiguration</code></p>
<p> 在此注解中,除开元注解就只有<code>@Configuration</code>,代表当前是一个配置类</p>
<p> 2 <code>@ComponentScan</code> 指定包扫描</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">3</span> `<span class="meta">@EnableAutoConfiguration</span>`   中描述的是:</span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure>

<p> 3.1 <code>@AutoConfigurationPackage</code> , 此注解中就是包含一个<code>@Import(&#123;Registrar.class&#125;</code> 利用Register来给容器导入一系列组件,对于Register来说里面的代码为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//去批量注册一些组件</span></span><br><span class="line">        AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code> 对于register的方法就是, 得到包名,然后封装到一个数组中,就是表示把这个包下的组件全部添加到容器之中。这就是为什么将是main方法所在的包及其子包的组件注册到容器中的原因了。
</code></pre>
<p> 3.2 <code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>对于AutoConfigurationImportSelector类来说中有一个selectImports（）方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在上面的代码中，需要了解的就是getAutoConfigurationEntry(annotationMetadata) 给容器中怎么批量导入组件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.<span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<pre><code> 以上代码中 重要的是`List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);  configurations = this.removeDuplicates(configurations)` 下面的就是对于结果进行排除和删除的筛选操作. 此代码就是获取所有需要导入到容器中的组件.
</code></pre>
<p> 在此方法中的实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br></pre></td></tr></table></figure>



<pre><code> 利用工厂加载 `private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader)`得到所有的组件.分析 loadSpringFactories 方法
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先查找一个资源文件 资源文件的位置META-INF/spring.factories</span></span><br><span class="line"><span class="comment">//在spring-boot-AutoConfigure的jar中的spring.factories文件下,有着大量的xxxAutoConfiguration,全场景的自动配置都在其中,说明springboot启动时,就要给容器中加载的所有配置类</span></span><br></pre></td></tr></table></figure>



<p>​    由于并不是所有的组件都是我们必须的,所以springboot就有按需开启自动配置项.在很多类的注解有<code>@Conditionalxxx</code>,所以要满足对应的条件才能生效</p>
<pre><code> 在某些方法上会同时标注`@ConditionalOnBean(xxx.class)` 和 `@ConditionalMissingBean(name=xxx)` 这这种情况. 第一个是容器中有该类型的组件,第二个是没有这个名字的组件,比如:
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnBean(&#123;MultipartResolver.class&#125;)</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean( name = &#123;&quot;multipartResolver&quot;&#125;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> resolver;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p> 目的就是防止你乱命名~~.</p>
<pre><code> 总结就是: springboot会先加载所有的自动配置类(xxxAutoConfiguration)导入组件,组件的值在xxxxproperties中拿值,xxxxproperties从配置文件中获取值.有一系列定制化配置,在springboot启动的组件中,主要是先以用户的为主,用户没有配置的,springboot会再根据自己的配置文件来进行配置.
</code></pre>
<p>在yml文件中 value的值单引号和双引号的区别 : 双引号就是原本的意思 比如 \n 在单引号作为文本输出,双引号自动转义成换行符.</p>
<h2 id="springboot的web开发"><a href="#springboot的web开发" class="headerlink" title="springboot的web开发"></a>springboot的web开发</h2><h4 id="静态资源资源目录"><a href="#静态资源资源目录" class="headerlink" title="静态资源资源目录"></a>静态资源资源目录</h4><p>​    类路径下:<code>static</code>   <code>public</code>    <code>resource</code>  <code>META-INF/resource</code><br>​    访问项目根路径/就可以访问<br>​    原理 : 静态资源映射/**  会拦截所有的请求; 请求进来,先去controller看能不能处理,如果能处理就去controller,不能处理就交给静态资源处理器.静态资源如果也找不到就会报出404的结果.</p>
<h4 id="静态资源访问的前缀"><a href="#静态资源访问的前缀" class="headerlink" title="静态资源访问的前缀"></a>静态资源访问的前缀</h4><p>默认是无前缀</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/xxx/**</span></span><br></pre></td></tr></table></figure>

<p>表示所有的静态资源的访问路径都要加上xxx/才能访问.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">classpath:/xxx/</span></span><br></pre></td></tr></table></figure>

<p>表示在类路径下的xxx文件夹才是静态资源的存放位置</p>
<h4 id="静态资源配置原理"><a href="#静态资源配置原理" class="headerlink" title="静态资源配置原理"></a>静态资源配置原理</h4><p>​    springboot启动默认加载 xxxAutoConfiguration 类(自动配置类)<br>​    springbootMVC功能的自动配置类 都集中在WebMvcAutoConfiguration中.</p>
<h5 id="配置类只有一个有参构造器"><a href="#配置类只有一个有参构造器" class="headerlink" title="配置类只有一个有参构造器"></a>配置类只有一个有参构造器</h5><pre><code> 那么所有参数的值都会在容器中进行查找并添加到容器中去.
</code></pre>
<h4 id="restful风格"><a href="#restful风格" class="headerlink" title="restful风格"></a>restful风格</h4><p>分为表单提交和利用客户端直接提交:</p>
<p>​    表单提交首先表单要使用post方式,且表单中要使用一行name为_method ,value为指定的方式(delete,put..)的这样一行数据.还要开启springmvc的此功能. 在yml中 <code>spring.mvc.hiddenmethod.filter.enable=true</code> 即可.原理是利用filter拦截请求,分析请求方式,然后在进行wrapper包装成对应的请求方式.</p>
<p>rest使用客户端工具直接发送,就会直接显示该请求方式,无需使用filter.</p>
<h4 id="请求映射原理"><a href="#请求映射原理" class="headerlink" title="请求映射原理"></a>请求映射原理</h4><p>​    我们知道所有的请求都会来到dispatcherServlet中,原理还是使用的是springmvc的部分.最终是要继承HttpServlet,下面为整个的继承树</p>
<p><img src="/2021/05/15/springboot/image-20210529222903580.png" alt="image-20210529222903580"></p>
<p>​    通过在HttpServlet向下开始找doGet和doPost方法,在FrameworkServlet中找到对应的方法,发现不管是doGet,doPost,doPut..等等都会调用<code>this.processRequest(request, response)</code>此方法,在此方法中,除开关闭资源,和开始的初始化功能,最重要的就是其中的<code>doService(request,response)</code>方法了,在FrameworkServlet中doService是一个抽象方法,所以在看DispatcherServlet中的doService方法.其中除开关闭资源和初始化部分,又是只有一个方法<code>this.doDispatch(request, response)</code>(<strong>针对某部分看哪些是重要的代码就看try里面的部分</strong>),现在就是主要的研究的是此方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                    processedRequest = <span class="keyword">this</span>.checkMultipart(request); <span class="comment">//检查是否为文件上传请求</span></span><br><span class="line">                    multipartRequestParsed = processedRequest != request; </span><br><span class="line">                    mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest); <span class="comment">//决定哪个handler能解析当前的请求</span></span><br><span class="line">                   <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123; <span class="keyword">this</span>.noHandlerFound(processedRequest, response);<span class="keyword">return</span>; &#125;</span><br><span class="line">                    HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                    String method = request.getMethod();</span><br><span class="line">                &#125; </span><br></pre></td></tr></table></figure>

<p>​    所以分析<code>getHandler(processedRequest)</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var2 = <span class="keyword">this</span>.handlerMappings.iterator();</span><br><span class="line">            <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                HandlerMapping mapping = (HandlerMapping)var2.next();</span><br><span class="line">                HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> handler;&#125;&#125;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<pre><code> 使用迭代器去逐个遍历,判断哪个handlerMapping中的handler可以解析当前的请求, 可自行翻阅源码,全是一直调用,差点迷路了
</code></pre>
<p>​    <code>@RequestBody</code> 获得请求体的信息,只有post请求才有请求体.(post包括put,delete)</p>
<h5 id="cookie被禁用了-session里面的内容怎么获得"><a href="#cookie被禁用了-session里面的内容怎么获得" class="headerlink" title="cookie被禁用了,session里面的内容怎么获得?"></a>cookie被禁用了,session里面的内容怎么获得?</h5><p>​    首先session的使用原理,每个session都有一个jsessionid,保存在cookie里面,而cookie每次发请求都会携带.通过cookie中的jsessionid获取到对应的session对象.<br>​    如果cookie被禁用了,jsessionid也会被禁用,那么session对象也将获取不到.怎么样去使用session呢?<br>​    可以使用url的重写 ,利用矩阵变量  /xxx;jsessionid=xxx . 把相当于是吧cookie里面的值利用矩阵变量的方式进行传递.在入参数使用@MatrixVariable注解即可.</p>
<p>​    而springboot默认关闭矩阵变量功能,需要手动开启:<br>​    在springboot中对于web的处理就是使用的springmvc.所以在springmvc中对路径的处理,就是UrlPathHelper进行解析.其中有一个removeSemicolonContent (移除分号内容)默认为true,那怎么去实现呢? 首先在配合类<code>@Configuration</code>中 可以去实现 WebMvcConfigurer,再去实现 <code>configurePathMatch</code>方法即可.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        UrlPathHelper urlPathHelper=<span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">        <span class="comment">//不移除分号后面的内容;</span></span><br><span class="line">        urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">        configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    或者使用在配置类中用@Bean的方法来进行注册</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer()&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">              UrlPathHelper urlPathHelper=<span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">              <span class="comment">//不移除分号后面的内容;</span></span><br><span class="line">              urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">              configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h4><p>分析DispatcherServlet中的dispatch方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">				multipartRequestParsed = (processedRequest != request);</span><br><span class="line">				<span class="comment">// Determine handler for the current request.</span></span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">				<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">					noHandlerFound(processedRequest, response);<span class="keyword">return</span>;&#125;</span><br><span class="line">				<span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">				<span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">				String method = request.getMethod();</span><br><span class="line">				<span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">				<span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">					<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet)<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) <span class="keyword">return</span>;</span><br><span class="line">				<span class="comment">// Actually invoke the handler.</span></span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">				<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) <span class="keyword">return</span>;</span><br><span class="line">				applyDefaultViewName(processedRequest, mv);</span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br></pre></td></tr></table></figure>



<p>​    上面说到<code>this.doDispatch(request, response)</code>方法中,获取到能解析的handler之后,又要开始进行参数的解析与适配,所以 <code>HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler())</code>方法就起到了这个作用. 也就是:</p>
<ul>
<li>先从HandlerMapping中知道能处理请求的Handler(controller中对应的Method);</li>
<li>再为当前的Handler找到对应的适配器  HanderAdapter</li>
<li>最后开始执行 <code>ha.handle(...)</code>注释中也能看得到,将请求和响应和对应的Handler放入此方法中.</li>
</ul>
<p>接着向下追溯源码,以RequestMappingHandlerAdapter为例来说的话,分析<code>handleInternal(...)</code>方法的<code>mav = invokeHandlerMethod(request,response, handlerMethod);</code>此行代码;  此行代码就是执行目标方法.</p>
<p>拿到此方法的try部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">			ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">			ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">				invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">				invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">			&#125;</span><br><span class="line">			invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">			invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">			ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">			mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">			modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">			mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">			AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">			asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">			WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">			asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">			asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">			asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">			asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">				Object result = asyncManager.getConcurrentResult();</span><br><span class="line">				mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">				asyncManager.clearConcurrentResult();</span><br><span class="line">				LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">					String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">					<span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">				&#125;);</span><br><span class="line">				invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">			<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br></pre></td></tr></table></figure>

<p>​    由上而下开始逐步分析,首先是<code>this.argumentResolvers</code>为参数解析器,确定将要执行的方法中值为什么<br><img src="/2021/05/15/springboot/image-20210530223007086.png" alt="image-20210530223007086"></p>
<p>​    以上如0表示,当你的参数上注解为@RequestParam时,就为0来进行解析参数,所以springmvc支持哪些参数类型,取决去这些解析器.<br>分析argumentResolvers参数所代表的的接口:</p>
<p><img src="/2021/05/15/springboot/image-20210530223739907.png" alt="image-20210530223739907"></p>
<p>判断当前的解析器是否支持这种参数,支持就调用此方法,不支持就下一个循环.而返回值处理器<code>this.returnValueHandlers</code>跟<code>this.argumentResolvers</code>原理是一样的</p>
<p>​    然后进行下面的开始准备执行此行代码 <code>invocableMethod.invokeAndHandle(webRequest, mavContainer);</code>通过追溯此代码发现,真正执行我们写的Controller层的方法的是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServletInvocableHandlerMethod</span></span><br><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br></pre></td></tr></table></figure>

<p>​    那是怎么执行到我们方法的呢,开始进入此方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object[] args = <span class="keyword">this</span>.getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doInvoke(args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    开始 <code>this.getMethodArgumentValues(...)</code>开始获得方法中所有的参数.接下来就是执行反射部分的代码了.</p>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>​    要实现HandlerInterceptor接口,三个方法 : preHandle(在进入方法之前) postHandle(执行完目标方法之后) afterCompletion(请求完成以后)</p>
<p>​    要在<code>@Configuration</code>注解所标注的类中进行注册</p>
<h4 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h4><ol>
<li>根据当前url请求,找到可以处理此请求的Handler以及handler的所有的拦截器,在DispatcherServlet类中的<code>doDispatch()</code>方法中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) <span class="keyword">return</span>;</span><br><span class="line">				<span class="comment">// Actually invoke the handler.</span></span><br><span class="line">		mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">				<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted())<span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>​    在此方法中,先是调用了<code>applyPreHandle()</code>方法,在此方法里面会循环对应的拦截器,进行拦截验证.里面的拦截器再调用perHandle方法.</p>
<ol start="2">
<li>先是<strong>顺序的执行</strong>所有拦截器的preHandle方法<pre><code>如果当前拦截器返回的true,则执行下一个拦截器
如果当前的拦截器返的false,直接触发**倒序执行**所有的已经执行了的拦截器的afterCompleion
</code></pre>
</li>
<li>如果任何一个拦截器返回false,直接跳出不执行目标方法.</li>
<li>所有的拦截器都返回true,才执行目标方法.</li>
<li><strong>倒序执行</strong>拦截器的postHandle方法.</li>
<li>前面的步骤有任何的异常,都会直接触发拦截器的afterCompletion方法</li>
</ol>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>在springboot中的文件上传还是用到了springmvc的功能,多了一个文件上传自动配置类-MultipartAutoConfiguration-MultipartProperties,并且自动配置好了StandardServletMultipartResolver文件上传解析器</p>
<p>原理步骤:</p>
<ul>
<li>请求进来使用文件上传解析器判断并封装好文件上传请求</li>
<li>参数解析器来解析请求中的文件内容封装成MultipartFIle</li>
<li>将request中的文件信息封装成一个Map;MultiValueMap&lt;String,MultipartFIle&gt;</li>
</ul>
<h3 id="内嵌服务器"><a href="#内嵌服务器" class="headerlink" title="内嵌服务器"></a>内嵌服务器</h3><ul>
<li>首先springboot应用启动发现当前是Web应用,会导入web场景包导入tomcat</li>
<li>web应用会创建一个web版的ioc容器<code>ServletWebServerApplicationContext</code></li>
<li><code>ServletWebServerApplicationContext</code>启动的时候会寻找<code>ServletWebServerFactory</code></li>
<li>springboot底层有很多的webServer工厂: tomcat,jetty undertow,netty</li>
<li>底层会有一个自动配置类.<code>ServletWebFactoryAutoConfiguration</code></li>
<li><code>ServletWebFactoryAutoConfiguration</code>配置类,根据动态的判断系统中导入了那个Web服务器的包.(默认是tomcat包),容器中就有对用web服务器的ServletWebServerFactory</li>
<li><code>TomcatServletWebServerFactory</code>创建除了tomcat服务器并且启动</li>
<li>内嵌服务器,就是手动把启动服务器代码进行调动就行.</li>
</ul>
<h4 id="切换服务器"><a href="#切换服务器" class="headerlink" title="切换服务器"></a>切换服务器</h4><p>在spring-boot-starter-web中排除掉tomcat服务器,再加上指定的服务器依赖即可.</p>
<h3 id="定制化Web"><a href="#定制化Web" class="headerlink" title="定制化Web"></a>定制化Web</h3><p>一旦使用<code>@EnableWebMvc</code>将全面接管springmvc,所有的功能全由自己定制.</p>
<p>使用<code>@EnableWebMvc</code>,会<code>@Import(DelegatingWebMvcConfiguration.class)</code></p>
<p><code>@Import(DelegatingWebMvcConfiguration.class)</code>的作用</p>
<ul>
<li>把所有系统中的WebMvcConfigurer拿过来,所有功能的定制都是这些写configurer 合起来一起生效</li>
<li>自动配置了一些底层的组件RequestMappingHandlerMapping等等,这些组件依赖的组件都是从容器中获取.</li>
<li>只保证了springmvc的最基本的使用,不保证其他扩展配置</li>
</ul>
<p>如果使用了<code>@EnableWebMvc</code>那么就会默认导入<code>DelegatingWebMvcConfiguration.class</code>,而<code>WebMvcAutoConfiguration</code>要生效,里面的配置必须满足<code>@ConditionOnMissingBean(WebMvcConfigurationSupport.class)</code>,而<code>DelegatingWebMvcConfiguration.class</code>是继承<code>@ConditionOnMissingBean(WebMvcConfigurationSupport.class)</code>的,所以,当使用<code>@EnableWebMvc</code>时候,容器中有了<code>WebMvcConfigurationSupport.class</code>类型的组件.所以spring的<code>WebMvcAutoConfiguration</code>就不生效了</p>
<h4 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h4><p>编写一个配置类+<code>@Bean</code>实现WebConfigurer来替换或者增加容器中的组件即可.</p>
<h3 id="redis的整合"><a href="#redis的整合" class="headerlink" title="redis的整合"></a>redis的整合</h3><p>​    首先导入依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot</span><br><span class="line">spring-boot-starter-data-redis</span><br></pre></td></tr></table></figure>

<p>首先是对查看RedisAutoConfiguration 自动配置类，redisProperties属性类<br>同时支持两个客户端一个是Lettuce，一个是Jdis</p>
<p>自动注入了redisTemplate&lt;Object,Object&gt;,StringRedisTemplate&lt;String,String&gt;,底层使用这两种template即可进行操作redist</p>
<h3 id="Junit的整合"><a href="#Junit的整合" class="headerlink" title="Junit的整合"></a>Junit的整合</h3><p>​    在springboot2.2.0之后的版本springboot开始引入了junit5作为单位单元测试默认库。</p>
<p>​    现在junit5 分为三部分：</p>
<ul>
<li>​    JUnit platform：他是在JVM上启动测试框架的基础，不仅支持JUnit自制的测试引擎，而且其他的测试引擎也可以进行接入</li>
<li>​    JUnit提供了Junit5的新的编程模型，是JUnit5的新特性的核心，内部包含了一个测试引擎，用于阿在JUnit platform中运行</li>
<li>​    JUnit Vintage：由于Junit发展了多年，为了照顾老的项目，Junit Vintage提供了兼容Junit4和3的测试引擎</li>
</ul>
<p>注意：springboot2.4以上的版本移除了对Vintage的依赖，如果需要兼容需要自行引入依赖即可。</p>
<h3 id="指标监控"><a href="#指标监控" class="headerlink" title="指标监控"></a>指标监控</h3><p>​    我们每个微服务都可以快速引用获得生产级别的应用监控，审计等功能。</p>
<p>​    导入依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>开启后，springboot会开放两个接口，一个为/actuator/health，用来监控服务的健康情况，一个为/actuator/info，查看服务的详细信息。</p>
<h3 id="profile功能"><a href="#profile功能" class="headerlink" title="profile功能"></a>profile功能</h3><p>​    为了多环境的适配，springboot简化了profile的功能.</p>
<p>​    可以在配置文件中配置多个application-xxx.yml的文件.xxx代表着不同的环境.接下来可以在主配置文件中写上spring.profiles.active=xxx即可.</p>
<p>​    配置规则:</p>
<ul>
<li>不带xxx后缀的配置文件为默认配置文件,永远都会加载.</li>
<li>在默认配置文件中激活制定的不同环境的配置文件.</li>
<li>默认配置语环境配置将会同时生效.</li>
<li>如果有同名的冲突的,以带后缀的配置文件优先.</li>
<li>可以在jar包处使用命令行的方式进行启动jar包  (命令行的优先级最高)<ul>
<li>java -jar xxx.jar –spring.profiles.active=xxx 来进行指定环境启动即可.</li>
</ul>
</li>
</ul>
<h2 id="疑问点"><a href="#疑问点" class="headerlink" title="疑问点"></a>疑问点</h2><p> 什么时候使用@Component而不能用@Bean?</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"># 学习</a>
              <a href="/tags/spring/" rel="tag"># spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2021/05/15/%E6%B3%A8%E8%A7%A3Bean%E5%92%8CComponent%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="next" title="注解Bean和Component的区别">
      注解Bean和Component的区别 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cw</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

</body>
</html>
